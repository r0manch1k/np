# Лекция 1. Введение в NP

_Лекция написана студентом Соколовским Романом Вадимовичом из группы Б9123-01.03.02сп под руководством преподавателя Месенёва Павла Ростиславовича_

### Содержание

1. Введение
1. Машина Тьюринга
1. Классы задач
1. Сведение и полнота
1. Пространственная сложность
1. Источники

## 1. Введение

Временная сложность вычислительных задач представляет большой интерес как для теоретических, так и для практических приложений. В частности, многие проблемы, представляющие интерес, такие как $SAT$ (задача выполнимости булевых формул) и $TSP$ (задача коммивояжёра), принадлежат к большому классу, известному как $NP$.

Несмотря на их важность, многие из этих задач не имеют известных эффективных алгоритмов. Давний вопрос заключается в том, существуют ли эффективные полиномиальные алгоритмы для решения этих задач. Проблемы с такими эффективными алгоритмами, как говорят, относятся к классу $P$, и вопрос более кратко сформулирован так: $P \neq NP$ ?

Если так, то мы не можем иметь алгоритмы, которые находят оптимальные решения за полиномиальное время для любого случая.

## 2. Машина Тьюринга

До того, как появились компьютеры, Алан Тьюринг в 1930-х изучал абстрактную машину, которая обладала всеми возможностями современных компьютеров, по крайней мере в том, что касалось вычислений. Целью Тьюринга было точно описать границу между тем, что может делать вычислительная машина, и тем, чего она сделать не может.

В 1969 году C. Кук расширил исследование Тьюринга о том, что можно и чего нельзя вычислить, и смог отделить те задачи, которые могут
быть эффективно решены с помощью компьютера, от тех задач, которые в принципе могут быть решены, но на практике требуют так много времени, что компьютеры бесполезны для решения всех задач, кроме очень небольшого количества их экземпляров (частных случаев задачи). Последний класс проблем называется неразрешимыми
или $NP$-сложными.

Цель теории неразрешимых проблем состоит не только в том, чтобы установить существование таких проблем, что само по себе является захватывающей идеей, но и в том, чтобы дать программистам представление о том, чего они могут или не могут достичь с помощью программирования.

Теорию неразрешимости принято строить не на программах на Си или другом языке, а на очень простой модели компьютера, машине Тьюринга. Одно из преимуществ машины Тьюринга перед программами в плане представления того, что может быть вычислено, заключается в том, что машина Тьюринга достаточно проста, чтобы мы могли точно представить ее конфигурацию, используя простые обозначения. Также описания состояний в программах слишком сложны, чтобы мы могли сделать понятные формальные доказательства.

**Машина Тьюринга** — абстрактный исполнитель (абстрактная вычислительная машина), математическая модель вычислений, предложенная Аланом Тьюрингом в 1936 году для формализации понятия алгоритма.

Машина Тьюринга $\mathfrak{M}$ состоит из _внешнего алфавита_ $\Sigma$ (множество символов, из которых составлен вход и выход машины), внутреннего алфавита $\Gamma$ (в процессе вычисления машине разрешается использовать некоторые дополнительные символы), конечное множетсво состояний $Q$ с обозначенными начальным состоянием $q_0$ и конечным состоянием $q_F$ (или $q_{halt}$) и, что самое главное, конечного множества правил перехода $\Delta$.

Каждое правило перехода в $\Delta$ имеет вид $\left<p, a\right> \rightarrow \left<q, b, d\right>$, где $p, q \in Q, a,b \in \Gamma$, и $d \in \{L, R, N\}$.

На каждом шагу, машина хранит одно из состояний (из $Q$) в своей внутренней памяти и находится на одной из ячеек _бесконечной ленты_. Лента считается бесконечной, однако в конкретный момент времени только конечная часть ленты заполнена данными. Для удобства мы предполагаем, что остаток ленты заполнен _пустым_ символом $BLANK \in \Gamma - \Sigma$.

Правила $\mathfrak{M}$ интерпретируются следующим образом. Если существует правило $\left<p, a\right> \rightarrow \left<q, b, d\right>$ в $\Delta$, машина сохраняет состояние $p$ в своей внутренней памяти и видит ячейку с записанным там $a$, то $\mathfrak{M}$ разрешается выполнить следующий ход:

1. заменить $a$ на $b$ в ячейке
1. заменить состояние $p$ на состояние $q$ во внутренней памяти
1. осуществить перемещение по ленте согласно $d$: если $d = L$, то двигаемся на одну ячейку влево; если $d = R$, то на одну ячейку вправо; если $d = N$, то остаемся на той же ячейке

Машина Тьюринга называется _детерминированной_, если для каждого $p \in Q$ и $a \in \Gamma$ существует не более одного правила перехода вида $\left<p, a\right> \rightarrow \left<q, b, d\right>$. Детерминированная машина _всегда знает, что делать_.

Как только машина приходит к состоянию $q_F$, она останавливается. Мы предполагаем, что полученное слово на ленте состоит только из символов из $\Sigma$; это результат вычислений. Если применяемое правило отсутствует, машина останавливается безрезультатно. Также существует возможность бесконечного выполнения.

Для _недетерминированных_ машин Тьюринга возможно более одной траектории выполнения, и некоторые из них могут быть успешными (но, возможно, с разными результатами), в то время как другие - нет.

**Определение.** Говорят, что машина Тьюринга $\mathfrak{M}$ имеет временную сложность $t(|x|)$, если всякий раз, когда $\mathfrak{M}$ задается входной сигнал $x$, $\mathfrak{M}$ останавливается после выполнения не более $t(|x|)$ ходов.

Здесь и далее $|x|$ означает длину $x$ в битах.

## 3. Классы задач

### Задача разрешимости (Decision problem)

В задаче разрешимости ответом может быть либо _да_, либо _нет_. Аналогично, задача разрешимости может быть представлена в виде набора $A$ возможных входных данных, на который ответ будет _да_ (т.е. $A \subseteq \Sigma^*$, где $\Sigma^\*$ - слова, составленных из букв алфавита $\Sigma$). $A$ также называют _языком_.

> **Пример.** Пусть машина Тьюринга принимает на вход $0$ и $1$ (т.е. $\Sigma =  \\{0, 1\\} $). Рассмотрим задачу разрешимости, которая звучит следующим образом: _Содержит ли строка четное число единиц?_. Тогда языком будет $A = \\{x \in \\{0, 1\\}^{*} : x \text{ содержит четное число единиц }\\}$.

**Определение.** Язык $A$ разрешим за полиномиальное время (обозначачется $A \in P$), если существует детерминированная Машина Тьюринга $\mathfrak{M}$, которая решает эту задачу разрешимости (проверяет, что данный $x \in A$), и существует многочлен $p$, такой, что для любого входного сигнала $x$ временная сложность $\mathfrak{M}$ не превышает $p(|x|)$.

**Определение.** Язык $A$ принадлежит классу $NP$, если он решается за полиномиальное время недетерминированной машиной Тьюринга $\mathfrak{M}$, то есть $x \in A$ тогда и только тогда, когда существует угаданное _успешное выполнение_ $\mathfrak{M}$ на $x$, возвращающее _да_ не более чем через $p(|x|)$ шагов.

То есть, $NP$ - это набор задач, решаемых за полиномиальное время недетерминированной машиной Тьюринга.

> **Замечание.** Так как каждая детерминированная машина Тьюринга это недетерминированная машина Тьюринга, которая не делает выбора куда двигаться, то $P \subseteq NP$. Детерминированная машина как бы находит решение для полученных входных данных, а недетерминированная машина способна мгновенно угадывать экспоненциальное число возможных решений задачи и параллельно проверять каждое из них за полиномиальное
> время.

**Определение (эквивалентное).** Язык $A$ принадлежит классу $NP$, если существует (детерминистически) полиномиально разрешимое бинарное отношение (подмножество декартова произведения множеств) $R$ такое, что $x \in A$ тогда и только тогда, когда существует _сертификат (подсказка, доказательство)_ $y$ полиномиального размера такой, что $R(x, y)$ - истина (алгоритм возвращает _да_ для $R$). Бинарное отношение $R$ также называют _верификатором_.

То есть, $NP$ - это набор задач принятия решений, которые можно проверить за полиномиальное время с помощью детерминированной машины Тьюринга.

> **Пример.** Расмотрим задачу о гамильтоновом путе (путь проходит через каждую вершину ровно один раз). Обозначим её как язык $HAMPATH = \\{\left<G, s, t\right>: G \text{ - направленный граф с гамильтоновым путём от } s \text{ до } t\\}$. Тогда сертификат $y$ будет представлять собой непосредственно гамильтонов путь от вершины $s$ до вершины $t$. Верификатор $R(\left<G, s, t\right>, y)$ проверяет, является ли $y$ подграфом $G$ и проходит ли путь все вершины ровно один раз. Если да, то решение $x = \left<G, s, t\right>$ принимается и $(\left<G, s, t\right>, y) \in R$ (или $\left<G, s, t\right> \in HAMPATH$), в обратном случае - отверагется. В рассмотренном случае верификатор $R$ может за полиномиальное время проверить, что входные данные были введены на том языке, на котором ему выдан сертификат.

Эквивалентность данных определений показывается следующим образом. Если у нас есть недетерминированная машина Тьюринга, то мы можем просто угадать правильное значение $y$ и запустить алгоритм для $R$. В обратную сторону, предположим, что все недетерминированные разветвления бинарные (выбор из двух правил правил перехода). Общее количество таких разветвлений на кажом вычислительном пути ограничено $p(|x|)$. Пусть наш _сертификат_ $y$ содержит $p(|x|)$ битов и каждый раз, когда нам требуется делать недетерминированный выбор, мы берём следующий бит $y$ и делаем на его основе выбор.

Суммируя вышесказанное, сделаем следующие выводы:

1. $P$ - класс языков, принадлежность к которым _решается_ за полиномиальное время
1. $NP$ - класс языков, принадлежность к которым _проверяется_ за полиномиальное время каким-то уже недетерминированно найденым сертификатом

### Функциональная задача (Function problem)

Функциональная задача определяется как отношение $A \subseteq \Sigma^* \times \Sigma^*$. Алгоритм решает $A$, если для любых входных данных $x$ существует удовлетворяющее $y$ такое, что $(x, y) \in A$. Алгоритм выдает такой $y$ и если такого нет, отвергает.

> **Пример.** Всем изместная задача $SAT$ на разрешимость булевой формулы имеет функциональный аналог $FSAT$, который выглядит следующим образом: _Дана булева формула_ $\phi$ _с переменными_ $x_1, x_2, ..., x_n$. _Найти такие_ $x_i \in \\{TRUE, FALSE\\}$, _чтобы_ $\phi$ _была_ $TRUE$ _или принять решенение о том, что не существует такого набора переменных._ В этом случае $A$ состоит из пар закодированных булевых формул и удовлетворяющих наборов перменных.

Описание других классов вычислительных задач опустим, так как это не повлияет на понимание остального материала.

## 4. Сведение и полнота

Поскольку нет доказательств того, что $P \neq NP$, для конкретной $NP$ задачи невозможно доказать, что она не может быть решена полиномиально. Однако теория $NP$-Трудности ($NP-hardness$) предоставляет способ получения условных результатов. А именно, для некоторых конкретных задач можно доказать, что они не могут быть решены полиномиально, при условии, что $P \neq NP$.

**Определение.** Функция $f : \Sigma^* \longrightarrow \Sigma^*$ является вычислимой за полиномиальное время функцией, если существует машина Тьюринга $\mathfrak{M}$, работающая за полиномиальное время, которая останавливается, когда на её ленте остается только $f(x)$ при запуске с любыми входными данными $x$.

**Определение (Р. Карп).** Задача разрешимости $A$ является _полиномиально сводимой_ к другой задаче разрешимости $B$, если существует вычислимая за полиномиальное время функция $f$, определённая на всевозможных входных данных для $A$ так, что $x \in A \Longleftrightarrow f(x) \in B$. Обозначается $A \leq_P B$. Функцию $f$ называют _сведением_ $A$ к $B$.

**Теорема.** Если $A \leq_P B$ и $B \in P$, то $A \in P$.

> **Доказательство.** Пусть $\mathfrak{M}$ решает за полиномиальное время задачу разрешимости $B$ и $f$ явялется вычислимой за полиномиальное время функцией сведения задачи разрешимости $A$ к задаче $B$. Опишем полиномиальный алгоритм сведения $N$, решающий $A$, следующим образом:
>
> $$
> \begin{align*}
> N = &\text{ На вход } x: \\
> & 1. \text{ Вычисляем } f(x) \\
> & 2. \text{ Запускаем } \mathfrak{M} \text{ с } f(x) \text{ на входе и выдаём всё, что } \mathfrak{M} \text{ выдаёт } \\
> \end{align*}
> $$
>
> По условию $x \in A$ всякий раз, когда $f(x) \in B$, потому что $f$ - это сведение от $A$ к $B$. То есть $\mathfrak{M}$ принимает $f(x)$ всякий раз, когда $x \in A$. Более того, $N$ выполняется за полиномиальное время, потому что каждый из двух его этапов выполняется за полиномиальное время, а композиция из двух многочленов является многочленом.

Примеры подобных сведений будут приведены в Лекции 2.

> **Замечание.** Обратной теоремой будет являться то, что если $A \notin P$ и $A \leq_P B$, то $B \notin P$. Это показывает использование _прямого_ и _обратного_ сведения. Если мы хотим показать, что задача $A$ проста, мы можем сделать это, сведя ее к простой задаче $B$ (прямое сведение). И наоборот, если мы хотим
> показать, что $B$ является сложной задачей, мы делаем это, сокращая сложную задачу $A$ до $B$ (обратное сведение).

**Определение.** Задача разрешимости $B$ является $NP$-Трудной, если $A \leq_P B$ для любой задачи $A \in NP$.

Если окажется, что какая-то задача $B$ является $NP$-Трудной и в то же время принадлежит к $P$, тогда любая задача $A \in P$ также принадлежит к $P$, что значит $P = NP$. Если же $P \neq NP$, что $NP$-Трудная задача не имеет полиномиального решения.

**Определение.** Задача $A$ является $NP$-Полной, если $A \in N$ и она $NP$-Трудная.

**Теорема (Транзитивность).** Если $B$ является $NP$-Полной задачей и $B \leq_P C$, где $C \in NP$, то $C$ является $NP$-Полной.

> **Доказательство.** Нам нужно показать, что каждый язык $L$ за $NP$ полиномиальное время сводится к $C$. Мы знаем, что существует полиномиальное сведение $L$ к $B$ за время, непревосходящее $p(n)$. То есть, строка $w$ в $L$ длины $n$ отображается в строку $x$ в $B$ не более, чем за $p(n)$.
>
> Из условия мы имеем полиномиальное сведение $B$ к $C$; пусть оно занимает полиномиальное время $q(m)$. Это сведение отображает строку $x$ из $B$ в строку $y$ в $C$, занимая время $q(p(n))$. То есть, максимальное время, которое уходит на сведение $w$ к $y$ равно $p(n) + q(p(n))$, что является полиномом. Мы показали, что $L$ полиномиально сводима к $C$. Так как $L$ может быть любым языком из $NP$, то $C$ является $NP$-Полной.

**Теорема.** Если какая-либо $NP$-Полная задача $A \in P$, то $P = NP$.

> **Доказательство.** Из условия следует, что $A$ одновременно является $NP$-Полной и принадлежит $P$. Тогда все $L$ в $NP$ полиномиально сводятся к $A$. Таким образом, $L \in P$.

Это является, наверное, самой важной теоремой в данной лекции.

**Определение (С. Кук).** Задача разрешимости $A$ является _полиномиально сводимой_ к другой задаче разрешимости $B$, если существует машина Тьюринга $\mathfrak{M}$, работающая за полиномиальное время и решающая задачу $A$, используя _оракул_ (решатель для задачи $B$).

Опустим формальное определение оракула, которые требуют внедрения оракул-машин Тьюринга в материал лекции.

## 5. Пространсвтенная сложность

В этом разделе мы рассмотрим сложность вычислительных задач с точки зрения объема памяти, который для них требуется. _Время_ и _пространство_ - два наиболее важных фактора, которые мы учитываем при поиске практических решений многих вычислительных задач. Пространственная сложность имеет много общих черт с временной
сложностью и служит дополнительным способом классификации задач в соответствии с их вычислительной сложностью.

Как и в случае с временной сложностью, нам нужно выбрать модель для измерения пространства, используемого алгоритмом. Мы продолжаем использовать модель машины Тьюринга для по той же причине, по которой мы использовали его для измерения времени. Машины Тьюринга математически просты и достаточно близки к реальным компьютерам,чтобы выдавать значимые результаты.

**Определение.** Пусть $\mathfrak{M}$ - детерминированная машина Тьюринга, которая выдаёт результат за конечное число шагов при любых входных данных. Пространственная сложность $\mathfrak{M}$ определяется функцией $f: \mathbb{N} \longrightarrow \mathbb{N}$, где $f(n)$ - максимальное количество ячеек ленты, которые $\mathfrak{M}$ сканирует на любом входном
сигнале длиной $n$. Если пространственная сложность $\mathfrak{M}$ равна $f(n)$, мы также говорим, что $\mathfrak{M}$ выполняется в пространстве $f(n)$. Если $\mathfrak{M}$ - недетерминированная машина Тьюринга, в которой все ветви останавливаются на всех входных данных, мы определяем ее пространственную сложность $f(n)$ как максимальное количество ячеек ленты, которые $\mathfrak{M}$ сканирует в любой ветви своих вычислений для любых входных данных длиной $n$.

Обычно мы оцениваем пространственную сложность машин Тьюринга, используя асимптотические обозначения

**Определение.** Рассмотрим функцию $f: \mathbb{N} \longrightarrow \mathbb{R}^+$. _Классы пространственной сложности_ $SPACE(f(n))$ и $NSPACE(f(n))$ определяются следующим образом:

$$
\begin{align*}
SPACE(f(n)) &= \\{ L : L \text{ - это язык, решаемый детерминированной машиной Тьюринга с } O(f(n)) \text{ памятью }\\} \\
NSPACE(f(n)) &= \\{ L : L \text{ - это язык, решаемый недетерминированной машиной Тьюринга с } O(f(n)) \text{ памятью }\\}
\end{align*}
$$

**Теорема (У. Савич).** Для любой функции $f: \mathbb{N} \longrightarrow \mathbb{R}^+$, где $f(n) \geq n$, $NSPACE(f(n)) \subseteq SPACE(f^2(n))$. То есть любая недетерминированная машиина Тьюринга, использующая $f(n)$ памяти может быть представлена в виде детерминированно машины Тьюринга, используюшей только $f^2(n)$ памяти.

Доказательство этой теоремы будет излишне для данной лекции.

**Определение.** Пространственный класс сложности $PSPACE$ является языком, решаемым детерминированной машиной Тьюринга с использованием полиномиальной памяти. Другими словами,

$$
PSPACE = \bigcup_k SPACE(n^k)
$$

Мы также определяем $NPSPACE$, недетерминированный аналог $PSPACE$, в терминах классов $NSPACE$. Однако, $PSPACE = NPSPACE$ в силу теоремы Савича, поскольку квадрат любого многочлена по-прежнему является многочленом.

Отношения между классами сложности имеет вид:

$$
P \subseteq NP \subseteq PSPACE = NPSPACE \subseteq EXPTIME
$$

Здесь $EXPTIME = \bigcup_k TIME(2^{n^k})$.

**Определение.** Язык $B$ является $PSPACE$-Полным, если $B \in PSPACE$ и любой язык $A \in PSPACE$ такой, что $A \leq_P B$.

**Определение.** Пространственный класс сложности $L$ является языком, решаемым детерминированной машиной Тьюринга с использованием логарифмической памяти. Другими словами,

$$
L = \bigcup_k SPACE(\log{n})
$$

**Определение.** Пространственный класс сложности $NL$ является языком, решаемым недетерминированной машиной Тьюринга с использованием логарифмической памяти. Другими словами,

$$
NL = \bigcup_k NSPACE(\log{n})
$$

## Источники

1. https://math.uchicago.edu/~may/REU2017/REUPapers/ZhouJames.pdf

1. https://mrce.in/ebooks/Automata%20Theory,%20Languages,%20&%20Computation%20Introduction%203rd%20Ed.pdf

1. https://broman.dev/download/Introduction%20to%20the%20Theory%20of%20Computation%203rd%20Edition.pdf

1. https://ru.wikipedia.org/wiki/Машина_Тьюринга

1. https://homepage.mi-ras.ru/~sk/lehre/dm_hse/Cook_Levin.pdf
