# Максимальный разрез графа. Алгоритм Виллиамса

_Материал написан студентом Соколовским Романом Вадимовичом из группы Б9123-01.03.02сп и является адаптацией [оригинальной статьи](https://people.csail.mit.edu/rrw/2-csp-final.pdf) Райана Виллиамса 2005 года._

## 1. Введение

Степень сложности решения NP-трудных задач до сих пор во многом остается неопределенной. Для
некоторых задач интуитивно кажется, что лучшее, что можно сделать, — это рассмотреть каждое возможное решение,
но эта интуиция, как было показано, не работает во многих сценариях. Развитие улучшенных экспоненциальных алгоритмов в последнее время показывает, что для многих сложных задач можно сделать что-то
значительно быстрее, чем перебор, даже в худшем случае. Однако некоторые
фундаментальные задачи постоянно ускользают от исследователей, которым не удалось найти значительно лучшие алгоритмы; одним из
популярных примеров является $MAX-2-SAT$.

**Определение.** Задача $MAX-2-SAT$ яляется задачей определения максимального количества клозов в $2-SAT$ формуле, которые могут выполниться после присваивания значений переменным.

В последнее время всё больше проявляется теоретический интерес в решении $MAX-2-SAT$ за $O((2 - \epsilon)^n)$ шагов при любыx входных данных для какого-то $\epsilon > 0$. В отличии от таких задач как $Vertex \ Cover$ и $k-SAT$, где для улучшения тривиальных границ по времени достаточно было провести сложный анализ методов «разветвления и ограничения» (или присваивания значений), $MAX-SAT$ оказался сложнее. Некоторые из предыдущих работ смогли показать либо границу $(2 - \epsilon)^m$, где $m$ - количество клозов, либо аппроксимацию $(2 - \epsilon)^n$ (но $\epsilon \rightarrow 0$). Конечно, количество клозов может в общем случае быть куда больше, чем количество переменных, поэтому граница $(2 - \epsilon)^m$ даст прирост по скорости по сравнению с тривиальной границе только в некоторых частных случаях.

**Определение.** Задача $Vertex \ Cover$ яляется задачей определения такого подмножества вершин $S$ исходного графа $G$, что у каждого ребра $G$ хотя бы один конец является вершиной из $S$.

На момент написания статьи лучшая граница по времени для $MAX-2-SAT$ - это $O^*(2^{m/5})$ (т.е. для $m/n > 5$ она не лучше $2^n$). Частичный ответ на вопрос о существовании $(2 - \epsilon)^n$ алгоритма для $MAX-SAT$ был дан автором статьи (Райаном Виллиамсом), который доказал, что _разряжённый_ экземпляр задачи $MAX-k-SAT$ может быть решён за $(2 - \epsilon)^n$. То есть, для любых констант $k$ и $\Delta$ существует константа $c_{k,\Delta}$ такая, что $MAX-k-SAT$ с максимум $\Delta n $ клозами решается за $(c_{k,\Delta})^n$ шагов (однако, $c_{k,\Delta} \rightarrow 2$ при $\Delta \rightarrow \infin$ или $k \rightarrow \infin$). Также показано, что когда каждая переменная появляется в формуле максимум 3 раза, $MAX-2-SAT$ становится $NP$-Полной. но имеет $O(n3^{n/2})$ алгоритм. Все эти результаты остаются далеки от реального улучшения экспоненциального алгоритма, поэтому некоторые исследователи признают нахождение $(2 - \epsilon)^n$ алгоритма для $MAX-2-SAT$ (и/или $MAX-CUT$) открытой проблемой.

**Определение.** Задача $MAX-CSP$ яляется задачей определения максимального количества ограничений в $2-SAT$ формуле, которые могут выполниться после присваивания значений переменным.

## 2. Обозначения

Пусть $V = \\{x_1, x_2, \ldots, x_n\\}$ является набором переменных над каким-то конечными множествами $D_1, D_2, \ldots, D_n$ соответственно. Определим $q$-_ограничение_ на $V$ как функцию $c : D_1 \times D_2 \times \ldots \times D_n \rightarrow \\{0, 1\\}$, где $c$ зависит только от $q$ переменных из $V$. Для $q$-ограничения $c$ обозначим набор этих $q$ переменных как $vars(c) \subseteq V$. Набор $a$ каких-либо значений этих переменных из $V$ задан последовательностью присваиваний $x_{i_1} := v_1, x_{i_2} := v_2, \ldots, x_{i_q} := v_q$, где $i_j \in [n]$ и $v_{i_j} \in D_{i_j}$. Набор $a$ называется _удовлетворяющим_ ограничение $c$, если $vars(c)$ является подмножеством переменных, появляющихся в $a$, и $c(a) = 1$.

**Определение.** Задача $MAX-CSP$ яляется задачей определения такого присваивания значений переменным $x_1, x_2, \ldots, x_n$, при котором достигается максимальное количество выполняющихся ограничений $c$.

Пусть дано множество $S$, обзначим $S^{m \times n}$ множество матриц $m \times n$ с элементами из $S$.

В качестве $w$ обозначим наименьшее вещественное число такое, что для $\forall \epsilon > 0$ умножение матриц на кольцом может быть выполнено за время $O(n^{w + \epsilon})$. Не берём конкретное $w$, т.к. вполне вероятно, что могут придумать более быстрый алогритм.

<!-- Обозначим три типа умножения матриц: стандартное; умножение дистанции ($\oplus_d$) над $\mathbb{Z} \cup \\{-\infin, \infin\\}$ такое, что для $\forall A, B \in (\mathbb{Z} \cup \\{-\infin, \infin\\})^{n \times n}$ умножение дистанции $A \oplus_d B$ будет над ($\mathrm{min}$, $+$)-полукольцом (стандартное $+$ при умножение заменено на $\mathrm{min}$, а $\times$ на сложение); и булевое умножение $\oplus_b$ с заменой $+$ на $\vee$ (ИЛИ) и $\times$ на $\wedge$ (И). -->

## 3. Быстрое нахождение $k$-клик

Рассмотрим теорему для быстрого определения наличия $k$-клики и её вида в графе меньше, чем за $n^k$ шагов.

**Теорема.** Пусть $r \in \mathbb{Z}^+$. Тогда наличие $3r$-клики в неориентированном графе определяется за $O(n^{wr})$.

> **Доказательство.** Рассмотрим случай $k = 3$ (то есть $r = 1$). Пусть дан граф $G = (V, E)$, $n = |V|$ и $A(G)$ является матрицей смежности. Известный факт, что $tr(A(G)^3) \neq 0$, только если в графе $G$ есть треугольник. В данном случае требуется два последовательных перемножения матриц за $O(n^w)$.
>
> Для $3r$-клик при $r > 1$ построим граф $G_r = (V_r, E_r)$, где вершинами в $V_r$ являются $r$-клики в графе $G$, а $E_r = \\{\\{c_1, c_2\\} : c_1, c_2 \in V_r, c_1 \cup c_2 - 2r\text{-клики в графе} \ G\\}$. Каждый треугольник в графе в $G_r$ соответствует уникальной $3r$-клике в $G$. Максимальное количество $r$-клик в графе $G$ равно $O(n^r)$ (из формулы сочетаний), тогда в итоге получаем $O(n^{wr})$.
>
> Если существует $i$ такое, что $A(G_r)^3[i, i] \neq 0$, то чтобы найти $3r$-клику из графа $G$, перебираем все соединённые с $i$-й кликой $j$-клики и наконец ищем для $j$-клики соединённую с ней $k$-клику. Таким найдём исходную клику за $O(n^{2r})$. (Рекомендую это понять, так как таким образом можно восстановить ответ при решении алгоритмом Виллиамса).

## Алгоритм для 2-CSP

Сначала формально опишем нашу задачу, а именно $COUNT-2-CSP$.

На вход подаётся множество из $m$ $1$-ограничений и $2$-ограничений $C$ с переменными $x_1, x_2, \ldots, x_n$ со значениями из множеств размеров $d_1, d_2, \ldots, d_n$ соответственно, а также параметр $N \in \\{0, 1, \ldots, m\\}$.

Необходимо найти количество присваиваний $A$ значений переменным ($0 \leq A \leq \prod_{i = 1}^n d_i$), при которых выполняется ровно $N$ ограничений.

Для простоты предположим, что $d_1 = d_2 = \ldots = d_n = d$.

Также чтобы единообразно описывать асимптотику нашего быстрого алгоритма для поиска $k$-клик при $k = 3r$, асимптотику других алгоритмов для $k \neq 3r$, а также возможных будущих улучшений, введём следующую функцию. Пусть $\kappa(k)$ таково, что число $k$-клик на неориентированных графах с $n$ узлами можно найти за время $O(n^{\kappa(k)})$. Cледует также отметить, что $k$ может быть функцией от $n$, в этом случае $\kappa(k)$ также может быть функцией от $n$.

**Теорема.** Пусть $k(n) \geq 3$ является монотонной невозрастающей функцией. Тогда задачу $COUNT-2-CSP$ можно решить за $O\left(\binom{N - \binom{k(n)}{2} - 1}{\binom{k(n)}{2} - 1}[k(n) d^{n / k(n)}]^{\kappa(k(n))}\right)$, где $m$ - количество ограничений, $n$ - количество переменных и $d$ - размер области определения переменных.

**Следствие.** Задачи $MAX-2-SAT$ и $MAX-CUT$ могут быть решены за время $O(m^3 1.729^n)$.

> **Доказательство (Следствие).** По условию $d = 2$ и $k = 3$. Возьмём в качестве $\kappa(k(n)) = \omega \approx 2.371$. Найдём максимальное $N$ такое, что существует хотя бы одно присваивание $a$, удовлетворяющее $N$ ограничениям. Для этого потребуется дополнительный фактор $O(m)$.

> **Доказательство (Теорема).** Сведём задачу к нахождению $k$-клик в большом графе. Пусть количество переменных $n$ кратно $k$. Дано множество ограничений $C$. Произвольным образом разобьём $n$ переменных на множества $P_1, P_2, \ldots, P_k$, в каждом из которых содержится $n/k$ переменных. Для каждого $P_i$ определим список $L_i$ всех $d^{n/k}$ присваиваний значений переменным в $P_i$.
>
> _Шаг 1: Распредление ответственности_
>
> По условию каждое ограничение зависит от одной или двух переменных, которые в свою очередь могут находиться в максимум двух разных множествах. Назовём конкретные разбиения $P_i$ (или пары разбиений $P_i$ и $P_j$) _ответственными_ за выполение конкретных ограничений, если переменные, от которых зависимо ограничения входят в $P_i$ (или $P_i$ и $P_j$).
>
> Обозначим $[k] = \\{1, \ldots, k\\}$ и $\binom{k}{2}$ за все пары из $[k]$. Определим _функцию ответственности_ $r : C \rightarrow ([k] \cup \binom{k}{2})$, сопоставляющую ограничение с разбиением или парой разбиений:
>
> - $r(c) := i \in [k]$, если $vars(c) \subseteq P_i$,
> - $r(c) := \\{i, j\\} \in \binom{k}{2}$, если $vars(c) \cap P_i \neq \emptyset$ и $vars(c) \cap P_j \neq \emptyset$.
>
> Интуитивно $r(c) = i$ $(r(c) = \\{i, j\\})$ значит, что $P_i$ является ответственным ($P_i$ и $P_j$ являются ответственными) за выполнение ограничения $c$. Функция $r$ однозначно определена, т.к. по условию $|vars(c)| \leq 2$.
>
> _Шаг 2. Определение весов_
>
> Далее построим взвешенный граф $H = (V, E)$ такой, что
>
> $$
> V = \bigcup^k_{i = 1} L_i \\
> E = \\{\\{u, v\\} : u \in L_i, v \in L_j \Rightarrow i \neq j\\}
> $$
>
> Таким образом, граф $H$ является $k$-дольным с $d^{n/k}$ вершинами в каждой доле. Для вершины $v$ из какого-то множества $L_i$ обозначим за $a_v$ частичное присваивание значений переменным, соответствующее $v$ (_я так понимаю, что $a_v$ определяет присваивание относительно исходного набора переменных, в то время как $v$ относительно своего разбиения $P_i$, иначе смысл введения $a_v$ мне непонятен_). Веса $w$ для графа для вершин и ребёр графа $H$ определим следующим образом:
>
> - $w(v) := |\\{r(c) = i : c \in C, v \in L_i, c(a_v) = 1\\}|$,
> - $w(\\{u, v\\}) := |\\{r(c) = \\{i, j\\} : c \in C, u \in L_i, v \in L_j, c(a_u a_v) = 1\\}|$.
>
> Функция $c(a)$ однозначно определена, т.к. все значения переменных из $vars(c)$ определены в $a$.
>
> В общем случае $w(t)$ показывает число ограничений $c \in C$, для которых одновременно выполняются следующие условия: (a) $t$ входит в разбиение (пару разбиений), ответственное (ответственных) за выполнение ограничения $c$; (b) частичное присваивание, задаваемое $t$, удовлетворяет ограничению $c$.
>
> Для случая $k = 3$ и $d = 2$ в [оригинальной статье](https://people.csail.mit.edu/rrw/2-csp-final.pdf) есть рисунок на странице 5.
>
> Пусть $K = \\{v_1, \ldots, v_k\\}$ является $k$-кликой в $H$. Определим $w(K) := \sum^k_{i = 1} w(v_k) + \sum_{\\{i, j\\} \in \binom{k}{2}} w(\\{v_i, v_j\\})$, т.е. сумма весов всех вершин и ребёр, входящих в $K$.
>
> **Утверждение.** Количество $k$-клик веса $N$ в $H$ равно количеству присваиваний, удовлетворяющих ровно $N$ ограничениям в $C$.
>
> **Доказательство.** Пусть $a$ является присваиванием для всех $n$ переменных и удовлетворяет ровно $N$ ограничениям в $C$. Тогда существуют уникальные $v_i \in L_i$ для $i = 1, \ldots, k$ такие, что $a = a_{v_1} a_{v_2} \ldots a_{v_k}$, т.е. $a$ соответствует уникальной клике $K_a = \\{v_1, \ldots, v_k\\}$ в $H$. Получаем, что
>
> $$
> w(K_a) = \sum_{i = 1}^k |\\{r(c) = i : v \in L_i, c(a_v) = 1 \\}| + \\ + \sum_{\\{i, j\\} \in \binom{k}{2}} |\\{r(c) = \\{i, j\\} : u \in L_i, v \in L_j, c(a_u, a_v) = 1\\}|
> $$
>
> Иными словами, $w(K_a)$ подсчитывает число ограничений $c \in C$, удовлетворяемых присваиванием $a$, таких что либо $r(c) = i \in [k]$ для некоторого $i$, либо $r(c) = \\{i,j\\} \in \binom{[k]}{2}$ для некоторых $i,j$. Однако, как было показано выше, отображение $r(c)$ однозначно определено для всех $c \in C$, поэтому величина $w(K_a)$ в точности равна числу ограничений, удовлетворяемых присваиванием $a$.
>
> Поскольку между $k$-кликами в графе $H$ и присваиваниями множеству $C$ существует взаимно однозначное соответствие, причём $k$-клики веса $N$ соответствуют присваиваниям, удовлетворяющим ровно $N$ ограничениям, утверждение доказано.
>
> _Шаг 3. Сведение взвешенного графа к невзвешенному_
>
> Здесь возникает небольшая трудность: в приведённой выше конструкции требуется подсчитывать $k$-клики, однако эффективный алгоритм подсчёта $k$-клик работает лишь для невзвешенных графов. Эту трудность можно устранить, добавив мультипликативный множитель, полиномиальный по $N \le m$, но экспоненциальный по $k$.
>
> Рассмотрим кортежи $(i_{1,2}, i_{1,3}, \ldots, i_{k-1,k})$ с индексами из $\binom{k}{2}$, где $i_{j,\ell} \in [N]$ и $i_{1,2} + i_{1,3} + \cdots + i_{k-1,k} = N$. Для каждого такого кортежа построим граф $H_{(i_{1,2}, i_{1,3}, \ldots, i_{k-1,k})}$, в котором (невзвешенные) рёбра между вершинами $v_j \in L_j$ и $v_\ell \in L_\ell$ добавляются согласно следующим правилам:
>
> - если $j = 1$ и $l = 2$, то кладём ребро $\\{v_1, v_2\\}$ в $H_{(i_{1,2}, i_{1,3}, \ldots, i_{k-1,k})}$, если $w(v_1) + w(v_2) + w(\\{v_1, v_2\\}) = i_{1,2}$,
> - если $j = 1$ и $l > 2$, то кладём ребро $\\{v_1, v_l\\}$ в $H_{(i_{1,2}, i_{1,3}, \ldots, i_{k-1,k})}$, если $w(v_l) + w(\\{v_1, v_l\\}) = i_{1,l}$,
> - если $j > 1$, то кладём ребро $\\{v_j, v_l\\}$ в $H_{(i_{1,2}, i_{1,3}, \ldots, i_{k-1,k})}$, если $w(\\{v_j, v_l\\}) = i_{j,l}$.
>
> (Заметим, что значения $w(v_j)$ и $w(\\{v_j, v_\ell\\})$ лежат в диапазоне $[m]$; это ограничивает возможные значения $i_{j,\ell}$.) Далее, для каждой $k$-клики $K = \\{v_1, \ldots, v_k\\}$, появляющейся в невзвешенном графе $H_{(i_{1,2}, i_{1,3}, \ldots, i_{k-1,k})}$ (их подсчёт занимает время $O\left([k d^{n/k}]^{\kappa(k)}\right)$, так как у нас $d^{n/k}$ вершин в каждой из $k$ долей), получаем, что величина $N$ равна:
>
> $$
> \sum_{\\{j, l\\} \in \binom{k}{2}} i_{j, l} = [w(v_1) + w(v_2) + w(\\{v_1, v_2\\})] + \\ + \sum_{\\{1, l\\} \in \binom{k}{2}, l > 2} [w(v_l) + w(\\{v_1, v_l\\})] + \\ + \sum_{\\{j,l\\} \in \binom{k}{2}, j > 1} w(\\{v_j, v_l\\}) = w(K)
> $$
>
> Таким образом, для каждая $k$-клика в графе $H_{(i_{1,2}, i_{1,3}, \ldots, i_{k-1,k})}$ является $k$-кликой с весом $N$ в $G$. Более того, каждый $H_{(i_{1,2}, i_{1,3}, \ldots, i_{k-1,k})}$ соответствует новому (непересекающемуся с остальными) набору $k$-клик веса $N$ в $H$. То есть сумма всех $k$-клик в $H_{(i_{1,2}, i_{1,3}, \ldots, i_{k-1,k})}$ равна числу $k$-клик веса $N$ в $H$.
>
> Возможные кортежи с индексами из $ \binom{k}{2}$ являются решениями уравнения $i_{1,2} +  i_{1,3} + \ldots + i_{k-1,k} = N$ и их количество равно $\binom{N - \binom{k(n)}{2} - 1}{\binom{k(n)}{2} - 1}$ - просто поставили перегородки.

## Релизация алгоритма для MAX-CUT

Теперь на основе приведённого алгоритма решим задачу $MAX-CUT$ на языке **Go**.

**Определение.** Задача $MAX-CUT$ заключается в нахождении такого разбиения множества вершин неориентированного графа $G = (V, E)$ на два непересекающихся подмножества $V_1$ и $V_2$, при котором максимизируется число рёбер $\\{u,v\\} \in E$, для которых $u \in V_1$ и $v \in V_2$.

В нашем случае $k = 3$ и $d = 2$. Присваивания для удобства будем называть раскрасками.

### Задача

Входные данные содержат: число $K$ — количество вершин на первой строке. Далее на отдельных строках идут пары вершин, соединённых рёбрами.

Требуется указать множество полученное оптимальным разбиением, включающее первую вершину. Если возможных разбиений несколько, вывести любое, содержащее первую вершину.

### Инициализация исходного графа

Исходный граф $G$ будет представлен матрицей смежности.

```go
// Исходное количество вершин
var K int

fmt.Scan(&K)

// Делаем количество вершин кратным трём
n = (K + 2) / 3 * 3

G = make([][]bool, n)
for i := 0; i < n; i++ {
    G[i] = make([]bool, n)
}

var u, v int

for {
    _, err := fmt.Scanln(&u, &v)
    // Пробел или EOF
    if err != nil {
        break
    }
    G[u-1][v-1] = true
    G[v-1][u-1] = true
    m += 1
}
```

Если изначальное количество вершин меньше трёх, то ответ можно дать сразу

```go
if K < 3 {
    fmt.Println("1")
    return
}
```

### Определение функции весов

Так как $d = 2$, то переменные могут принимать лишь два значения. В нашем случае - 0 и 1 (принадлежность к одному и двух множеств).

Поделим вершины графа $G$ на разбиения $P_1, P_2, P_3$ самым тривиальным способом: $P_1 = \\{1, \ldots, n / 3\\}, P_2 = \\{n / 3 + 1, \ldots, 2n / 3\\}, P_3 = \\{2n / 3 + 1, \ldots, n\\}$.

Алгоритм определения веса заключается в проверке наличия ребра в $G$ и различия цветов его концов.

```go
// Считает количество переходных ребёр при данных раскрасках Li и Lj в подмножетсвах Pi и Pj графа G
func w(Li int, Lj int, i int, j int) uint8 {
	var transitions uint8
	// Вспомогательные переменные для оптимизации подсчёта
	var pshift, qshift int
	// Количество вершин в подмножестве G
	K := n / 3
	for p := i * K; p < (i+1)*K; p++ {
		pshift = p - i*K
		for q := j * K; q < (j+1)*K; q++ {
			qshift = q - j*K
			if G[p][q] && ((1<<pshift)&Li > 0) != ((1<<qshift)&Lj > 0) {
				transitions += 1
			}
		}
	}
	if i == j {
		transitions /= 2
	}
	return transitions
}
```

### Заполнение графа H

Теперь можем строить граф $H$. Более того, мы можем сразу присвоить веса для дальнейшего построения графов $H_{(i_{1,2}, i_{2,3}, i_{1,3})}$.

```go
// Суммарное количество вершин (присваиваний/раскрасок) в долях графа H
K := 3 * (1 << (n / 3))

// Трёхдольный граф H
H := make([][]uint8, K)
for i := range K {
    H[i] = make([]uint8, K)
}

// Размер доли в H
var H_part_size int = 1 << (n / 3)

// Вспомогательные переменные для хранения индексов
var a, b int

// Находим веса H вариантом из статьи
for j := range 3 {
    for l := j + 1; l < 3; l++ {
        for Lj := range H_part_size {
            a = j*H_part_size + Lj
            for Ll := range H_part_size {
                b = l*H_part_size + Ll
                if j > 0 {
                    H[a][b] = w(Lj, Ll, j, l) // i23
                } else if (j == 0) && (l > 1) {
                    H[a][b] = w(Ll, Ll, l, l) + w(Lj, Ll, j, l) // i12
                } else {
                    H[a][b] = w(Lj, Lj, j, j) + w(Ll, Ll, l, l) + w(Lj, Ll, j, l) // i13

                }
                H[b][a] = H[a][b]
            }
        }
    }
}
```

### Поиск треугольников

В нашем случае $k = 3$. Тогда нахождение $k$-клики вырождается в поиск треугольника в графах $H_{(i_{1,2}, i_{1,3}, i_{2,3})}$.

Пройдемся по всем решениям уравнения $i_{1,2} + i_{1,3} + i_{2,3} = N \in [m]$, начиная с максимального $N$. Построим новый граф, оставив только нужные нам рёбра. Далее найдем проверяем наличие трегуольника в полученом графе.

```go
// Булевая матрица смежности для H при i12, i13 и i23
Hi := make([][]bool, K)
for i := range K {
    Hi[i] = make([]bool, K)
}

for N := m; N >= 0; N-- {
    for i12 := 0; i12 <= N; i12++ {
        for i13 := 0; i13 <= N-i12; i13++ {
            i23 := N - i12 - i13
            // Заполняем матрицу с конкретными i12, i13 и i23
            for j := range 3 {
                for l := j + 1; l < 3; l++ {
                    for Lj := range H_part_size {
                        a = j*H_part_size + Lj
                        for Ll := range H_part_size {
                            b = l*H_part_size + Ll
                            if j > 0 {
                                Hi[a][b] = H[a][b] == uint8(i23)
                            } else if (j == 0) && (l > 1) {
                                Hi[a][b] = H[a][b] == uint8(i13)
                            } else {
                                Hi[a][b] = H[a][b] == uint8(i12)
                            }
                            H[b][a] = H[a][b]
                        }
                    }
                }
            }

            // Можно оптимизировать, не заполняя матрицу каждый раз полностью,
            // а при умножении считать веса

            tr := triangle(Hi)
            if tr != nil {
                return tr
            }
        }
    }
}
```

Саму функцию поиска треугольника можно немного улучшить, т.к. матрица булевая

```go
// Ищет первый попавшийся треугольник в булевой матрице A
// Возвращает отсортированный массив индексов вершин из разных долей
func triangle(A [][]bool) []int {
	for i := range len(A) {
		for j := i + 1; j < len(A); j++ {
			if !A[i][j] {
				continue
			}
			for k := j + 1; k < len(A); k++ {
				if A[i][k] && A[j][k] {
					return []int{i, j, k}
				}
			}
		}
	}
	return nil
}
```

### Восстановление решения

При нахождении треугольника результатом будет кортеж индексов раскрасок соответствующих разбиений, которые все вместе полностью красят $G$.

```go
partition := maxcut()

// Часть, к которой принадлежит первая вершина (её цвет)
color1 := partition[0] & 1

// Вспомогательная переменная для вывода веришн
first := true

for i, mask := range partition {
    for j := range n / 3 {
        if (mask>>j)&1 == color1 {
            if !first {
                fmt.Print(" ")
            }
            first = false
            fmt.Print(i*(n/3) + j + 1)
        }
    }

}
```

### Полный алгоритм

```go
// Гаечка. Задача о максимальном разрезе в графе. Алгоритм Виллиамса

package main

import (
	"fmt"
)

// n - количество вершин (округлённое вверх для кратности трём)
var n int

// m - количество ребёр
var m int

// G - исходный граф (с возможно доп. кол-вом вершин для кратности n трём)
var G [][]bool

// Считает количество выполненных ограничений при присваиваниях Li и Lj
//
// В нашем случае: Считает количество переходных ребёр при данных
// раскрасках Li и Lj в подмножетсвах Vi и Vj графа G
//
// Параметры i и j нужны для определения подмножетсва вершин в
// графе G (т.к. мы просто разбили их, поставив две "перегородки", то достаточно индекса)
//
// P.S. Работает примерно за O(n^2), если не считать сдвиги. Пока что-то быстрее не придумал
// Еще можно прикрутить кэширование
func w(Li int, Lj int, i int, j int) uint8 {
	var transitions uint8
	// Вспомогательные переменные для оптимизации подсчёта
	var pshift, qshift int
	// Количество вершин в подмножестве G
	K := n / 3
	for p := i * K; p < (i+1)*K; p++ {
		pshift = p - i*K
		for q := j * K; q < (j+1)*K; q++ {
			qshift = q - j*K
			if G[p][q] && ((1<<pshift)&Li > 0) != ((1<<qshift)&Lj > 0) {
				transitions += 1
			}
		}
	}
	if i == j {
		transitions /= 2
	}
	return transitions
}

// Ищет первый попавшийся треугольник в булевой матрице A
// Возвращает отсортированный массив индексов вершин из разных долей
func triangle(A [][]bool) []int {
	for i := range len(A) {
		for j := i + 1; j < len(A); j++ {
			if !A[i][j] {
				continue
			}
			for k := j + 1; k < len(A); k++ {
				if A[i][k] && A[j][k] {
					return []int{i, j, k}
				}
			}
		}
	}
	return nil
}

// Находит максимальный разрез, возвращая три маски для каждого поднможества вершин из G
func maxcut() []int {
	// Суммарное количество вершин (присваиваний/раскрасок) в долях графа H
	K := 3 * (1 << (n / 3))

	// Трёхдольный граф H
	H := make([][]uint8, K)
	for i := range K {
		H[i] = make([]uint8, K)
	}

	// Размер доли в H
	var H_part_size int = 1 << (n / 3)

	// Вспомогательные переменные для хранения индексов
	var a, b int

	// Находим веса H вариантом из статьи
	for j := range 3 {
		for l := j + 1; l < 3; l++ {
			for Lj := range H_part_size {
				a = j*H_part_size + Lj
				for Ll := range H_part_size {
					b = l*H_part_size + Ll
					if j > 0 {
						H[a][b] = w(Lj, Ll, j, l) // i23
					} else if (j == 0) && (l > 1) {
						H[a][b] = w(Ll, Ll, l, l) + w(Lj, Ll, j, l) // i12
					} else {
						H[a][b] = w(Lj, Lj, j, j) + w(Ll, Ll, l, l) + w(Lj, Ll, j, l) // i13

					}
					H[b][a] = H[a][b]
				}
			}
		}
	}

	// Булевая матрица смежности для H при i12, i13 и i23
	Hi := make([][]bool, K)
	for i := range K {
		Hi[i] = make([]bool, K)
	}

	// Здесь можно улучшить, по-умному перебирая решения i12 + i13 + i23 = N, N \in [m]
	for N := m; N >= 0; N-- {
		for i12 := 0; i12 <= N; i12++ {
			for i13 := 0; i13 <= N-i12; i13++ {
				i23 := N - i12 - i13
				// Заполняем матрицу с конкретными i12, i13 и i23
				for j := range 3 {
					for l := j + 1; l < 3; l++ {
						for Lj := range H_part_size {
							a = j*H_part_size + Lj
							for Ll := range H_part_size {
								b = l*H_part_size + Ll
								if j > 0 {
									Hi[a][b] = H[a][b] == uint8(i23)
								} else if (j == 0) && (l > 1) {
									Hi[a][b] = H[a][b] == uint8(i13)
								} else {
									Hi[a][b] = H[a][b] == uint8(i12)
								}
								H[b][a] = H[a][b]
							}
						}
					}
				}

				// Можно оптимизировать, не заполняя матрицу каждый раз полностью,
				// а при умножении считать веса

				tr := triangle(Hi)
				if tr != nil {
					return tr
				}
			}
		}
	}

	return nil
}

func main() {
	// Исходное количество вершин
	var K int

	fmt.Scan(&K)

	// Делаем количество вершин кратным трём
	n = (K + 2) / 3 * 3

	G = make([][]bool, n)
	for i := 0; i < n; i++ {
		G[i] = make([]bool, n)
	}

	var u, v int

	for {
		_, err := fmt.Scanln(&u, &v)
		// Пробел или EOF
		if err != nil {
			break
		}
		G[u-1][v-1] = true
		G[v-1][u-1] = true
		m += 1
	}

	if K < 3 {
		fmt.Println("1")
		return
	}

	partition := maxcut()

	// Часть, к которой принадлежит первая вершина (её цвет)
	color1 := partition[0] & 1

	// Вспомогательная переменная для вывода веришн
	first := true

	for i, mask := range partition {
		for j := range n / 3 {
			if (mask>>j)&1 == color1 {
				if !first {
					fmt.Print(" ")
				}
				first = false
				fmt.Print(i*(n/3) + j + 1)
			}
		}

	}
}
```

## Источники

1. https://people.csail.mit.edu/rrw/2-csp-final.pdf
