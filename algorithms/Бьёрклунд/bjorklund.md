# Задача о гамильтоновом цикле. Алгоритм Бьёрклунда

_Материал написан студентом Соколовским Романом Вадимовичом из группы Б9123-01.03.02сп и является адаптацией [оригинальной статьи](https://arxiv.org/pdf/1008.0541) Андерса Бьёрклунда 2010 года._

## 1. Введение

**Определение.** _Задача о гамильтоновом цикле_ является задачей определения наличия гамильтонового цикла в заданном графе.

... введение

В статье представлена задача определения _суммы маркированных покрытий графа циклами_ и её сведение к задаче о гамильтоновом цикле. Начнём с необходимых для определения задачи предварительных сведений.

## 2. Предварительные сведения

Рассмотрим _направленный_ граф $D = (V, A)$, где $V$ - множество вершин, а $A$ - множество _арок_ (направленных рёбер).

**Определение.** _Покрытием циклами_ вершин графа $D$ называется подмножетство арок $C \subseteq A$ такое, что каждой вершине $v \in V$ соответствует ровно одна арка $a_{v_1} \in C$, начинающаяся в $v$, и ровно одна арка $a_{v2}$, заканчивающася в $v$.

Рассматриваемые в этой статье графы не имеют _петель_ при вершинах, то есть арок, соединяющих вершину с собой же ($a_{v1} \neq a_{v2}$).

Обозначим $cc(D)$ множество всех покрытий циклами графа $D$ и $hc(D) \subseteq cc(D)$ множество гамильтоновых покрытий циклами графа $D$. Гамильтоновое покрытие циклами состоит из одного _большого_ цикла, проходящего через все вершины. Остальные покрытия циклами $cc(D)$ \\ $hc(D)$ назовём негамильтоновыми покрытиями циклами.

Хоть элементы $hc(D)$ формально являются подмножествами арок, мы будем иногда обозначать их $(v_0, v_1, \ldots, v_{n-1})$, имея в виду соответствующие арки $v_i v_{i+1}$ в гамильтоновом цикле.

Обозначим $g \ : A \twoheadrightarrow B$ _сюрьективное отображение_ $g$ из множетсва $A$ в множество $B$. Также обозначим для этой функции обратную $g^{-1} : B \rightarrow 2^A$, где $2^A$ - всевозможные подмножетсва $A$, то есть $g^{-1}(b) = \{a \in A : g(a) = b\}$.

> **Замечание.** Отображение $g \ : A \twoheadrightarrow B$ называется _сюрьективным_, если $\forall b \in B \ \exists a \in A :  b = g(a)$.

Также дальше мы будем рассматривать полиномы. Обозначим $[r^l]p(r)$ коэффициент при переменной $r^l$ в полиноме $p(r)$.

**Определение.** _Суммой маркированных покрытий циклами_ направленного графа $D = (V, A)$, множества маркировок $L$ и функции $f : A \times 2^L$ \\ $\\{ \emptyset \\} \rightarrow R$ для кольца $R$ называется

$$
\begin{align}
\Lambda(D, L, f) = \sum_{C \in cc(D)} \sum_{g \ : L \twoheadrightarrow C} \prod_{a \in C} f(a, g^{-1}(a))
\end{align}
$$

Внутренняя сумма проходит по всевозможным сюрьективным отображениям $g$, что значит $g^{-1}(a)$ всегда является непустым подмножеством маркировок. Также все подмножетсва маркировок у арок попарно непересекающиеся и все вместе покрывают $L$ полностью.

> **Замечание.** Множество $R$ называется _кольцом_, если на нём заданы две бинарные операции: $+$ и $\times$ (сложение и умножение), для которых выполняется _коммутативность сложения_, _ассоциативность сложения_, _существование нейтрального элемента относительно сложения_, _существование противоположного (обратного) элемента относительно сложения_, _ассоциативность умножения_, _дистрибутивность_, то есть минимальный нужный нам набор операций.

### A. Сокращение покрытий циклами в кольце характеристики два

> **Замечание.** _Характеристика_ — числовая величина, используемая в общей алгебре для описания некоторых свойств колец или полей. Для кольца $R$ характеристикой $\mathrm{char}(R)$ называется наименьшее целое $n > 0$ такое, что для каждого элемента $r \in R$ выполняется равенство:
>
> $$
> \underbrace {r+\cdots +r} _{n} = 0,
> $$
>
> а если такого числа не существует, то предполагается $\mathrm{char}(R) = 0$.

Покажем, что можно взять такие направленный граф, кольцо и функцию $f$, что сумма маркированных покрытий циклами будет состоять только из гамильтоновых покрытий, а негамильтоновые покрытия сократятся.

Для этого возьмём в качестве направленного графа _двунаправленный_, то есть для каждой арки $uv$ есть арка противоположного направления $vu$. Во-вторых, пусть кольцо $R$ имеет _характеристику два_. В-третьих, для случайно выбранной зафиксированной вершины графа $s$ возьмём $s$-_ориентированную зеркальную функцию_ $f : A \times 2^L$ \\ $\\{\emptyset\\} \rightarrow R$ такую, что $\forall Z \subseteq L$ и $\forall v, u \in V \ : \ u \neq s, v \neq s$ выполняется $f(uv, Z) = f(vu, Z)$. Это поможет сократить негамильтоновые покрытия циклами, но не гарантирует несокращение гамильтоновых, так как мы, во-первых, не установили неравенство $f(su) \neq f(us)$ для $\forall u \in V$, а просто позволили ему быть (это было бы избыточно) и, во-вторых, нет гарантии, что при отображении в $f$ существующие гамильтоновые циклы не сократятся.

Следующая лемма показывает, как исчезают негамильтоновые покрытия циклами, что также означает отсутствие ложных срабатываний (появление негамильтоновых циклов в итоговой сумме) в алгоритме.

**Лемма 1.** Дан двухнаправленный граф $D = (V, A)$, конечное множество маркировок $L$ и фиксированная вершина $s \in V$, пусть $f$ является $s$-ориентированной зеркальной функцией, отображаемой в кольцо $R$ характеристики два. Тогда

$$
\begin{align}
\Lambda(D, L, f) = \sum_{H \in hc(D)} \sum_{g \ : L \twoheadrightarrow H} \prod_{a \in H} f(a, g^{-1}(a))
\end{align}
$$

> **Доказательство.** Сумму маркированных покрытий графа циклами можно представить в виде кортежа $(C, g)$, где $C \in cc(D)$ и $g \ : L \twoheadrightarrow C$. Покажем, что маркированные негамильтоновые покрытия графа могут быть разделены на такие пары, что оба покрытия в одной паре превносят одинаковое слагаемое в сумму. Так как мы работаем в кольце характеристика два, такие слагаемые сокращаются.
>
> Рассмотрим негамильтоновые покрытия $(C, g)$. Определим отображение $M$ следующим образом: $M(C, g) = (C', g')$. Пусть $\textbf{C}$ является первым циклом в покрытии, не проходящим через $s$ (рисунок можно посмотреть в оригинальной статье -> [Figure. 1](https://arxiv.org/pdf/1008.0541)). Такой цикл существует, так как негамильтоновое покрытие состоит минимум из двух циклов, причём все циклы в покрытии не имеют общих вершин. Под первым циклом в покрытии имеется в виду первый в каком-то фиксированном порядке для такого набора циклов. Пусть $C' = C$, но в котором цикл $\textbf{C}$ _направлен в другую сторону_, то есть каждая арка $uv \in \textbf{C}$ заменена противоположной аркой $vu$ в $C'$. Такие арки существуют, так как граф $D$ двунаправленный. В случае, если $\textbf{C}$ состоит только из двух арок, покрытие $C'$ будет идентично $C$ (так как обе арки перейдут друг в друга). Определим функцию $g'^{-1}$ так, чтобы маркировки на арках оставались теми же, то есть $g'^{-1}(uv) = g^{-1}(vu)$ для $\forall uv \in \textbf{C}$. Заметим, что $(C, g) \neq M(C, g)$, а $(C, g) = M(M(C, g))$. Таким образом, $M$ определяет уникальные пары негамильтоновых покрытий, и они есть в сумме $\Lambda(D, L, f)$ при любом выбранном фиксированном порядке циклов в негамильтоновом покрытии.
>
> Так как $f$ является $s$-ориентированной зеркальной функцией, то есть $f(uv, Z) = f(vu, Z)$ для любой арки $uv$, не смежной с $s$ и для любого подмножества $Z \in 2^L$ \\ $\\{\emptyset\\}$, $(C, g)$ и $(C', g')$ превносят одинаковое слагаемое в сумму в $(1)$ и, следовательно, сокращаются.

### B. Обнаружение гамильтоновых циклов

В предыдущем разделе мы утверждали, что вклады негамильтоновых покрытий циклами в сумму нивелируются при выполнении определенных условий. Для того чтобы это было полезно, нам также необходимо, чтобы
гамильтоновы покрытия не обращались в нуль. С этой целью будет полезно рассматривать элементы $f$ как неконстантные полиномы нескольких переменных, зависимых от арки и множества меток. В частности, для вершин, смежных со специальной вершиной $s$, многочлены $f(su, X)$ и $f(us, X)$ не будут иметь одинаковые переменные для $\forall su, us \in A$. Это гарантирует, что гамильтоновы циклы, ориентированные в противоположных направлениях, будут вносить разные вклады в сумму, так как при характеристики два сокращаются только одинаковые элементы, а эти полиномы с разными переменными, а значит уже разлчаются.

Итак, разные полиномы в сумме не сокращаются, но их значения при подстановке значений переменных могут быть неутешительными. Чтобы определить, является ли полином, полученный в результате записи суммы маркированных покрытий циклами графа, тождественным нулем (=нет гамильтоновых циклов) или нет (=по крайней мере один гамильтонов цикл), мы вычислим полином в случайно выбранной точке. Если результат отличен от нуля, мы точно знаем, что полином не может быть нулевым. Если результат равен нулю, мы предполагаем, что полином также является нулевым. Лемма Шварца-Циппеля гарантирует, что с большой вероятностью мы будем правы.

**Лемма (Шварца-Зиппеля).** Пусть $P(x_1, x_2, \dots, x_n)$ явялется полиномом $n$ переменных с ненулевыми коэффициентами степени $d$ над полем $F$. Пусть $S$ - конечное подмножество $F$ и пусть элементы $r_1, r_2, \ldots, r_n$ были выбраны из $S$ равномерно и независимо друг от друга. Тогда

$$
\mathrm{Pr}(P(r_1, r_2, \ldots, r_n) = 0) \leq \frac{f}{|S|}
$$

Вычисление алгоритма в этой статье будет над конечным полем характеристика два - $GF(2^k)$ для некоторого $k$ после замены переменных на значения. Далее функция будет рассмотрена как неконстантный полином с коэффицентами из $GF(2)$, то есть просто переменные (а именно их произведение) без коэффициентов больше еденицы при них.

> **Замечание.** _Конечное поле_ или _поле Галуа_ - поле, состоящее из конечного числа элементов; это число называется _порядком_ поля. Конечное поле обычно обозначается $GF(q)$ (Galios Field). Порядок всегда является степенью какого-нибудь простого числа, то есть $q = p^k$, где $p$ - простое число, а $k$ - любое натуральное число. При этом $p$ будет являться характеристикой этого поля.
>
> Важными для нас свойствами такого поля являются:
>
> - Любое конечное поле $GF(q)$ - кольцо
> - Для любого элемента конечного поля характеристики два выполняется $x + x = 0$
>
> Не следует также путать конечные поля $GF(p^k)$ и [кольца вычетов](https://ru.wikipedia.org/wiki/Конечное_поле#Связь_с_кольцами_вычетов) $Z \\ (p^k)$.

### C. Вычисление суммы. Определитель

**Утверждение.** Определитель матрицы $\Theta$ размера $n \times n$ над кольцом характеристики два совпадает с _перманентом_, то есть:

$$
\mathrm{det}(\Theta) = \mathrm{per}(\Theta) = \sum_{\sigma \ : \ [n] \rightarrow [n]} \prod_{i = 1}^{n} \Theta_{i, \sigma}(i),
$$

где сумма идёт по всем перестановкам $n$ элементов.

> **Замечание.** Данный факт исходит из того, что в кольце характеристики два для любого элемента $-x + x = x + x = 0 \Rightarrow -x = x$.

Перманент можно интерпретировать как сумму взвешенных покрытий циклами направленного графа. Иначе говоря, пусть $D = (V, A)$ - направленный граф с весами $w \ : \ A \rightarrow R$, определим матрицу $\Theta$ размера $|V| \times |V|$ с строками и столбцами в качестве вершин $V$

$$
\Theta_{i, j} =
\begin{cases}
\begin{aligned}
&w(ij) &: ij \in A \\
&0 &: иначе
\end{aligned}
\end{cases}
$$

и тогда

$$
\begin{align}
\mathrm{per}(\Theta) = \sum_{C \in cc(D)} \prod_{a \in C} w(a)
\end{align}
$$

Вернёмся в сумме маркированных покрытий циклами. Для более удобного её вычисления выразим её в виде суммы определителей.

Для начала определим для всех $Z \subseteq L$ матрицы

$$
\begin{align}
M_f(Z)_{i, j} =
\begin{cases}
\begin{aligned}
&f(ij, Z) &: ij \in A, Z \neq \emptyset \\
&0 &: иначе
\end{aligned}
\end{cases}
\end{align}
$$

Сумма определителей будет представлена в виде полинома по переменной $r$

$$
\begin{align}
p(f, r) = \sum_{Y \subseteq L} \mathrm{det} [T_f(Y)] =
\sum_{Y \subseteq L} \mathrm{det} \left(\sum_{Z \subseteq Y} r^{|Z|} M_f(Z)\right)
\end{align}
$$

Для лучшего понимания рассмотрим подробнее внутреннюю матрицу, обозначенную за $T_f(Y)$. Пронумеруем для удобства все подмножества $Z \subseteq Y$ в порядке позрастания по их мощности, то есть $|Z_1| \leq |Z_2| \leq \ldots \leq |Z_{2^{|Y|}}|$. Тогда элементы матрицы будут иметь вид полинома

$$
\begin{align*}
T_f(Y)_{i, j} &= r^{|Z_{2^{|Y|}}|} f(ij, Z_{2^{|Y|}}) \\
&+ r^{|Z_{2^{|Y|} - 1}|} f(ij, Z_{2^{|Y|} - 1}) \\
&+ \ldots \\
&+ r^{|Z_{2^{|Y|} - C_{|Y|}^{|Y| - 1}}|} f(ij, Z_{2^{|Y|} - C_{|Y|}^{|Y| - 1}}) \\
&+ \ldots \\
&+ r^{|Z_2|} f(ij, Z_2) \\
&+ r^{|Z_1|} f(ij, Z_1),
\end{align*}
$$

если $ij \in A$. Конечно, $r^{|Z_1|} f(ij, Z_1) = 0$, так как $Z_1 = \emptyset$, но для удобства оставим.

При подсчёте определителя, а потом их сумм, будут появляться слагаемые, соответсвующие всевозможным маркировкам покрытий циклами и при каждой такой маркировке будет стоять переменная $r$ в степени, равной сумме мощностей всех подмножеств, участвующих в маркировке. Наверное очевидно, что максимальная такая степень будет равна $|L||V|$.

Полином почти приобритает вид суммы маркированных покрытий циклами $\Lambda(D, L, f)$. Он состоит из сумм произведений элементов из $R$. Конечно, если вспомнить определение $\Lambda(D, L, f)$, при произведении не может быть пересекающихся и не дающих $L$ при объединении подмножеств $g^{-1}(a)$ в силу того, что $g$ сюрьекция в $C$. В нашем случае пока что подмножества в одном слагаемом не удовлетворяют данным ограничениям.

Также заметим, что одной лишь суммой по $Y \subseteq L$ нельзя ограничиваться, так как мы потеряем? пока хз

Покажем, что если в $p(f, r)$ взять коэффициент при $r^{|L|}$, то в сумме останутся только подходящие нам элементы, а лишние сократятся в кольце характеристики два.

**Лемма 6.** Для направленного графа $D$, множества маркировок $L$ и любой функции $f \ : \ A \times 2^L$ \\ $\\{\emptyset\\} \rightarrow GF(2^k)$

$$
[r^{|L|}] p(f, r) = \Lambda(D, L, f)
$$

> **Замечание.** Знак вычитания далее множества может обозначаться как "/" из-за проблем с MathJax на GitHub.

> **Доказательство.** Перепишем формулу для $p(f, r) \ (5)$, используя эквивалентность определителя и перманента в кольце характеристики два $(2)$, интерпретацию перманента для покрытий циклами $(3)$ и матрицу $M_f \ (4)$, в виде
>
> $$
> p(f, r) = \sum_{Y \subseteq L} \sum_{C \in cc(D)} \sum_{q \ : \ C \rightarrow 2^Y / \\{\emptyset\\}} \prod_{a \in C} r^{|q(a)|} f(a, q(a))
> $$
>
> В принципе, если идти по рассуждениям выше, то понятно как рабоатет эта формула. Единственное, что стоит отметить, $q$ не является сюрьекцией, а это значит, что для каждой арки из покрытия могут использоваться подмножетсва маркировок $q(a) \in 2^Y$, не покрывающие всё $2^Y$, что создаёт соответствие с формулой $(5)$.
>
> Изменим порядок суммирования и получим
>
> $$
> p(f, r) =
> \sum_{С \in cc(D)}
> \sum_{q \ : \ C \rightarrow 2^L / \\{\emptyset\\}}
> {\sum_{\substack{
> \bigcup_{a \in C} q(a) \subseteq Y \\
> Y \subseteq L
> }}}
> \prod_{a \in C} r^{|q(a)|} f(a, q(a))
> $$
>
> В последней сумме идём по количетсву всех подмножеств $Y \subseteq L$, для которых $\bigcup_{a \in C} q(a)$ является подмножеством. Само $Y$ не используем.
>
> Для функций $q \ : \ C \rightarrow 2^L$ \\ $\\{\emptyset\\}$ таких, что $\bigcup_{a \in C} q(a) \subset L$, то есть чьё объединение при данном покрытии не покрывает всё множество $L$, получаем, что последнее суммирование происходит _чётное_ количетсво раз с одним и тем же слагаемым (таких слагаемых $2^{|L / \bigcup_{a \in C} q(a)|}$ штук, так как количетсво подмножеств $Y$, включающих подмножество $\bigcup_{a \in C} q(a)$ равно количеству подмножеств $L$ \\ $\bigcup_{a \in C} q(a)$ - чётное число). По итогу получаем
>
> $$
> p(f, r) =
> \sum_{C \in cc(D)}
> \sum_{\substack{
> q : C \to 2^L / \\{\emptyset\\} \\
> \bigcup_{a \in C} q(a) = L
> }}
> r^{\sum_{a \in C} |q(a)|} \prod_{a \in C} f(a, q(a))
> $$
>
> И в частности, коэффицикент при $r^{|L|}$
>
> $$
> [r^{|L|}] p(f, r) =
> \sum_{C \in cc(D)}
> \sum_{\substack{
> q : C \to 2^L / \\{\emptyset\\} \\
> \bigcup_{a \in C} q(a) = L \\
> \forall a \neq b \ : \ q(a) \cap q(b) = \emptyset
> }}
> \prod_{a \in C} f(a, q(a))
> $$
>
> Заметим, что $q$ отображает в подмножетсва, состоящие из одного элемента, то есть в элементы $L$. Обращая функцию $q$ получаем исходное определение суммы маркированных покрытий $(1)$.

```go
// Задача о гамильтоновом цикле. Алгоритм Бьёрклунда

// Соколовский Роман - 2025 г.

package main

import (
	"fmt"
	"math/rand"
)

// n - количество вершин (2 <= n <= 50)
var n int

// G - двунаправленный граф
var G [][]uint8

// s - специальная вершина
var s int

// k - степень конечного поля GF(2^k) (2 <= k <= 10)
var k int

// irredpolys - неприводимые полиномы над полем k-ой степени
// https://www.jjj.de/mathdata/all-irredpoly.txt
var irredpolys [10]uint16 = [10]uint16{
	0b111,          // 2,1,0
	0b1011,         // 3,1,0
	0b10011,        // 4,1,0
	0b100101,       // 5,2,0
	0b1000011,      // 6,1,0
	0b10000011,     // 7,1,0
	0b100011101,    // 8,4,3,2,0
	0b1000010000,   // 9,4,0
	0b10000001000,  // 10,3,0
	0b100000000100, // 11,2,0
}

func mul_gf(a uint16, b uint16) uint16 {
	var r uint16

	for range k {
		if b&1 > 0 {
			r ^= a
		}
		hi := a & (1 << (k - 1))
		a <<= 1
		if hi > 0 {
			a ^= irredpolys[k-2]
		}
		b >>= 1
	}
	return r & ((1 << k) - 1)
}

func lccs[T any](D [][]uint8, L []T, f func(int, int, []T) uint16) {

}

// func hamiltonicity_bipartite() bool {
// 	// L - матрица значений переменных x_{u,v}
// 	L := make([][]uint16, n)
// 	for i := range n {
// 		L[i] = make([]uint16, n)
// 	}

// 	// g - генератор чисел в GF(2^k)
// 	var g uint16 = irredpolys[k-2]

// 	// r - начальный элемент для генерации чисел из GF(2^k)
// 	var r uint16 = 1

// 	// Присваеваем значения для переменных x_{u,v}
// 	for i := range n - 1 {
// 		for j := n - 1; j > i; j-- {
// 			if G[i][j] > 0 {
// 				L[i][j] = r
// 				L[j][i] = r
// 				r = mul_gf(r, g)
// 			}
// 		}
// 	}

// 	// Делаем так, чтобы x_{u,v} != x_{v,u} при u == s || v == s
// 	for i := n - 1; i >= 0; i-- {
// 		if L[i][s] == 0 || i == s {
// 			continue
// 		}
// 		if i < s {
// 			L[s][i] = mul_gf(L[i][s], g)
// 		} else {
// 			L[i][s] = mul_gf(L[s][i], g)
// 		}
// 	}

// 	fmt.Println("L =")
// 	for _, row := range L {
// 		fmt.Println(row)
// 	}

// 	// f := func(u int, v int, X []int) uint16 {
// 	// 	if len(X) != 1 {
// 	// 		return 0
// 	// 	}
// 	// 	w := X[0]
// 	// 	return mul_gf(L[u][w], L[w][v])
// 	// }
// 	return true
// }

func hamiltonicity(V1 []int, V2 []int, m int) {
	// Берем k из условия 2^k > c*n
	for i := 10; i > 0; i-- {
		if ((len(V1))*(len(V2)+m))&(1<<i) > 0 {
			k = i + 1
			break
		}
	}

	// Собираем множество маркировок
	L := make([]int, len(V2)+m)
	copy(L, V2)

	// Делаем маркировки из L_m отрицательными числами
	for i := n; i < len(V2)+m; i++ {
		L[i] = -L[i-n]
	}

	// Вводим переменные x_{u,v,d} для арок в V1 и присваеваем им случайные значения
	// x_{u,v,0} = x_{u,v}
	VARS := make([][][]uint16, len(V1))
	for i := range len(V1) {
		VARS[i] = make([][]uint16, len(V1))
		for j := range len(V1) {
			VARS[i][j] = make([]uint16, m+1)
		}

	}

	// g - генератор чисел в GF(2^k)
	var g uint16 = irredpolys[k-2]

	// r - начальный элемент для генерации чисел из GF(2^k)
	var r uint16 = uint16(rand.Uint32())

	// Присваеваем значения для переменных x_{u,v}
	for i := range n - 1 {
		for j := n - 1; j > i; j-- {
			for p := range m + 1 {
				if G[i][j] > 0 {
					VARS[i][j][p] = r
					VARS[j][i][p] = r

				}
			}
			r = mul_gf(r, g)
		}
	}

	// Делаем так, чтобы x_{u,v} != x_{v,u} при u == s || v == s
	for i := n - 1; i >= 0; i-- {
		for j := range m + 1 {
			if VARS[i][s][j] == 0 || i == s {
				continue
			}
			if i < s {
				VARS[s][i][m] = mul_gf(VARS[i][s][m], g)
			} else {
				VARS[i][s][m] = mul_gf(VARS[s][i][m], g)
			}
		}

	}
}

func main() {
	// K - количество ребёр
	var K int

	fmt.Scan(&n, &K)

	G = make([][]uint8, n)
	for i := 0; i < n; i++ {
		G[i] = make([]uint8, n)
	}

	// U1, U2 - множества вершин в графе (|U1| = |U2|)
	V1, V2 := make([]string, n), make([]string, n)

	// a, b - вершины V1 и V2 соответственно
	var a, b string

	// p, q - вспомогательные счётчики для составления графа
	var p, q int

	for range K {
		fmt.Scan(&a, &b)

		for i := range V1 {
			if (V1[i] == "") || (V1[i] == a) {
				if V1[i] == "" {
					V1[i] = a
				}
				p = i
				break
			}
		}

		for j := range V2 {
			if (V2[j] == "") || (V2[j] == b) {
				if V2[j] == "" {
					V2[j] = b
				}
				q = j
				break
			}
		}

		G[p][q+n/2] = 1
		G[q+n/2][p] = 1
	}

	s = 1

	// Для двудольного графа берём m = 0
	hamiltonicity()

	// for _, row := range G {
	// 	fmt.Println(row)
	// }
}

```

```go
// Хоровод. Задача о гамильтоновом цикле в двудольном графе. Алгоритм Бьёрклунда

// Соколовский Роман - 2025 г.

package main

import (
	"fmt"
	"math/rand"
)

// n - количество вершин (2 <= n <= 50)
var n int

// G - двунаправленный двудольный граф
var G [][]uint8

// s - специальная вершина
var s int

// k - степень конечного поля GF(2^k) (2 <= k <= 10)
var k int

// irredpolys - неприводимые полиномы над полем k-ой степени
// https://www.jjj.de/mathdata/all-irredpoly.txt
var irredpolys [7]uint8 = [7]uint8{
	0b111,      // 2,1,0
	0b1011,     // 3,1,0
	0b10011,    // 4,1,0
	0b100101,   // 5,2,0
	0b1000011,  // 6,1,0
	0b10000011, // 7,1,0
}

func mul_gf(a_ uint8, b_ uint8) uint8 {
	// При умножении количество требуемых байт может увеличиться вдвое
	var r uint16
	a, b := uint16(a_), uint16(b_)
	irredpoly := uint16(irredpolys[k-2])

	for range k {
		if b&1 > 0 {
			r ^= a
		}
		hi := a & (1 << (k - 1))
		a <<= 1
		if hi > 0 {
			a ^= irredpoly
		}
		b >>= 1
	}
	return uint8(r)
}

func matmul_gf(A [][]uint8, B [][]uint8) [][]uint8 {
	AB := make([][]uint8, len(A))
	for i := range len(A) {
		AB[i] = make([]uint8, len(B[0]))
		for j := range len(B[0]) {
			for k := range len(B) {
				AB[i][j] += mul_gf(A[i][k], B[k][j])
			}
		}
	}
	fmt.Println("AB =")
	for _, row := range AB {
		fmt.Println(row)
	}
	return AB
}

// Умножение матрицы A на транспонированную B
func matmul_transpose_gf(A [][]uint8, B [][]uint8) [][]uint8 {
	AB := make([][]uint8, len(A))
	for i := range len(A) {
		AB[i] = make([]uint8, len(B))
		for j := range len(B) {
			for k := range len(B[0]) {
				AB[i][j] += mul_gf(A[i][k], B[j][k])
			}
		}
	}
	fmt.Println("AB_T =")
	for _, row := range AB {
		fmt.Println(row)
	}
	return AB
}

func hamiltonicity(V1 []int, V2 []int) bool {
	// Собираем множество маркировок
	L := make([]int, len(V2))
	copy(L, V2)

	// Вводим переменные x_{u,v} для арок в G и присваиваем им случайные значения
	VARS := make([][]uint8, n)
	for i := range n {
		VARS[i] = make([]uint8, n)
	}

	// g - генератор чисел в GF(2^k)
	var g uint8 = irredpolys[k-2]

	// r - случайный начальный элемент для генерации чисел из GF(2^k)
	var r uint8 = uint8(rand.Uint32()) & ((1 << k) - 1)

	fmt.Printf("g = %d, r = %d\n", g, r)

	// Присваиваем значения для переменных x_{u,v}
	for i := range n - 1 {
		for j := n - 1; j > i; j-- {
			// В теории присваиваем значения всем рёбрам, но
			// можно и так, потому что это условие останется,
			// просто будет в другом месте
			if G[i][j] > 0 {
				VARS[i][j] = r
				VARS[j][i] = r
				r = mul_gf(r, g)
			}
		}
	}

	// Делаем так, чтобы x_{u,v} != x_{v,u} при u == s || v == s
	for i := n - 1; i >= 0; i-- {
		if VARS[i][s] == 0 || i == s {
			continue
		}
		if i < s {
			VARS[s][i] = mul_gf(VARS[i][s], g)
		} else {
			VARS[i][s] = mul_gf(VARS[s][i], g)
		}
	}

	for _, row := range G {
		fmt.Println(row)
	}

	for _, row := range VARS {
		fmt.Println(row)
	}

	// Ищем все поднможества маркировок Y \subseteq L
	sc := 1 << len(L)
	for Y_mask := 1; Y_mask < sc; Y_mask++ {
		var Y_power int

		for i := 0; i < len(L); i++ {
			if Y_mask&(1<<i) > 0 {
				Y_power += 1
			}
		}

		Y := make([]int, Y_power)
		var p int
		for i := 0; i < len(L); i++ {
			if Y_mask&(1<<i) > 0 {
				Y[p] = L[i]
				p += 1
			}
		}

		fmt.Println("Y_mask =")
		fmt.Println(Y_mask)
		fmt.Println("Y =")
		fmt.Println(Y)

		// Инициализируем память для матрицы под перманентом
		T := make([][]uint8, len(V1))
		for i := range len(V1) {
			T[i] = make([]uint8, len(V1))
		}

		// Находим коффициенты для матрицы T
		for u := range len(V1) {
			for v := range len(V1) {
				if u == v {
					continue
				}

				// Согласно науке создаём матрицы A и B
				A := make([][]uint8, Y_power)
				for i := range Y_power {
					A[i] = make([]uint8, Y_power)
					for j := range Y_power {
						if VARS[Y[i]][Y[j]] > 0 {
							A[i][j] = VARS[Y[i]][Y[j]]
						}
					}
				}

				B := make([][]uint8, len(V1))
				for i := range len(V1) {
					B[i] = make([]uint8, Y_power)
					for j := range Y_power {
						fmt.Println(i, j, Y, L, Y_power, VARS[i][Y[j]])
						B[i][j] = VARS[i][Y[j]]
					}
				}
				// fmt.Println(u, v)
				// fmt.Println("A =")
				// for _, row := range A {
				// 	fmt.Println(row)
				// }
				// fmt.Println("B =")
				// for _, row := range B {
				// 	fmt.Println(row)
				// }
				// for _, row := range matmul_transpose_gf(matmul_gf(B, A), B) {
				// 	fmt.Println(row)
				// }
				T[u][v] = matmul_transpose_gf(matmul_gf(B, A), B)[u][v]
			}
		}

		fmt.Println("T =")
		for _, row := range T {
			fmt.Println(row)
		}
	}

	return true
}

func main() {
	// K - количество ребёр
	var K int

	fmt.Scan(&n, &K)

	G = make([][]uint8, n)
	for i := 0; i < n; i++ {
		G[i] = make([]uint8, n)
	}

	// U1, U2 - множества вершин в графе (|U1| = |U2| = n/2)
	U1, U2 := make([]string, n/2), make([]string, n/2)

	// a, b - вершины V1 и V2 соответственно
	var a, b string

	// p, q - вспомогательные счётчики для составления графа
	var p, q int

	for range K {
		fmt.Scan(&a, &b)

		for i := range U1 {
			if (U1[i] == "") || (U1[i] == a) {
				if U1[i] == "" {
					U1[i] = a
				}
				p = i
				break
			}
		}

		for j := range U2 {
			if (U2[j] == "") || (U2[j] == b) {
				if U2[j] == "" {
					U2[j] = b
				}
				q = j
				break
			}
		}

		G[p][q+n/2] = 1
		G[q+n/2][p] = 1
	}

	// Берем k из условия 2^k > c*n
	c := 2
	for i := 10; i > 0; i-- {
		if (c*n)&(1<<i) > 0 {
			k = i + 1
			break
		}
	}

	// Выбираем специальную вершину
	s = 1

	// Выбираем множетсва V1 и V2
	// Самое тривиальное разбиение - по долям
	V1, V2 := make([]int, n/2), make([]int, n/2)
	for i := range n / 2 {
		V1[i] = i
		V2[i] = n/2 + i
	}

	// Для такого разбиения в двудольном графе m = 0
	yes := hamiltonicity(V1, V2)

	if yes {
		fmt.Println("yes")
	} else {
		fmt.Println("no")
	}
}

```
